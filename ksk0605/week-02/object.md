# 객체란 무엇인가? 

> 인스턴스화 된 클래스, Array 입니다. - 토비의 스프링 강의 중

위 대답은 자바 개발자에게 기술적으로 최적화 된 대답이다. 
더 나아가 객체지향을 올바르게 사용하기 위해서는
객제지향이 무엇을 '지향'하고 있는지 아는 것이 필요하다. 

먼저 가장 핵심적인 구성요소이자 개념인 '객체'가 무엇인지 알아보자.

## 클래스 

클래스는 객체의 spec, 명세서이다.
혹자는 factory 라고 표현한다(클래스에는 생성자라는 개념이 있기 때문에 매우 적절한 표현이라고 생각한다). 
클래스라는 공장은 개발자가 작성한 명세대로(변수와 메서드) 객체를 생성한다. 

클래스는 실제로 인스턴스화 되었을 때 비로소 객체라고 불리울 수 있다.
우리는 클래스를 작성하는 행위를 통해 객체가 어떤 정보를 가져야 하며, 어떤 기능을 제공할 수 있는지 설계하는 행동을 한다. 

### 정의 

> 객체란 상태(state)와 행동(behavior)을 함께 가지며, 
> 다른 객체와 메시지를 주고 받으며 협력하는 자율적인 존재. 


> 객체지향은 객체들의 공동체를 설계하는 일이다. 각 객체는 협력 속에서 역할을 맡고, 책임을 수행한다. - 『오브젝트』, 조영호

- 즉, 객체는 ‘자신의 책임’을 알고 그 책임을 수행하는 존재.
- 그는 객체를 “데이터의 집합”이 아니라 협력 속의 참여자로 본다.
- 서로다른 객체들과 메시지를 주고받으며 전체 시스템의 기능을 완성한다.

> “Objects are the units of modularity in OO systems.” - Martin Fowler, UML Distilled

- 마틴 파울러는 객체를 시스템의 모듈화 단위라고 본다. 
- 객체는 내부 상태와 행위를 숨기고 외부에는 명확한 인터페이스만 노출한다. 
- 이로 인해 시스템은 유연하고 변경에 강해진다. 

두 명의 주장의 공통점은 객체의 의미를 큰 시스템(공동체)의 일부로 바라본다는 것이다. 
여기서 두가지 객체의 특징을 파악할 수 있다. 

- 객체는 단위이다. 그러나 미터, 그램 처럼 표준화된 단위가 아닌 개념적인 단위이다. 
- 객체는 단일로 존재할 수 없다. 큰 시스템 안에서만 의미를 지닌다. 

객체는 개념적인 단위이기 때문에 개발자마다 그 범위를 넓히거나 좁히는 것이 가능하다.
그리고 범위 설정의 기준은 관심사, 역할 혹은 책임 이라고 부르는 개념이 된다. 

누군가는 PaymentService가 환율을 외부에서 가져오는 역할까지 담당해도 문제가 없다고 생각할 수 있지만 
혹자는 아니라고 생각한다. 아니라고 생각하는 개발자는 WebApiExRateService 혹은 WebApiExRateProvider와 같은 
새로운 객체를 설계한다. 

PaymentService든 WebApiExRateProvider든 누군가 사용해주지 않으면 무의미해진다.
PaymentService가 Client 객체에게 prepare() 메소드를 사용 당함으로 비로소 제 역할을 다한다. 

이런 객체의 특징으로 부터 우리는 자연스럽게 좋은 객체의 조건이 낮은 결합도, 높은 응집도임을 기억해낼 수 있다. 
객체는 관심사를 표현하는 단위이기 때문에 관심사가 얼마나 잘 모아져있는지 평가할 수 있다. (응집도)
객체는 시스템 안에서 존재하기 때문에 객체가 사용하는, 객체가 사용당하는 과정 중에서 다른 객체와의 연관성이 생긴다. (결합도)

#### 왜 응집도는 높고 결합도는 낮아야 하는가? 

객체가 특정 시스템의 모듈, 즉 단위가 된다면 굳이 쪼개야만 하는 이유를 기억하는 것이 좋다. 
쪼갠다는 것은 해당 객체에게만 기대하는 기능이 있음을 의미한다. 
객체에게 기대하는 기능을 책임이라고 정의해보자. 그럼 객체는 맡겨진 책임에 최선을 다해야한다. 

PaymentService가 abstract 클래스이고 이를 상속한 WebApiExRatePaymentService와 SimpleExRatePaymentService는 PaymentService의 기능변경에 모두 영향을 받는다. 
이는 상속의 특징이기도 하지만 근본적인 원인은 상속받은 두 객체는 PaymentService가진 두가지 역할, 환율 가져오기, 결제 생성하기 를 같이 부여받기 때문이다.

상속을 통한 확장은 근본적으로 상위 객체의 책임을 물려받는다는 특징이 있다. 
상속받을 객체의 책임이 많다면 그 여파는 고스란히 전달된다. 즉, 높은 결합도가 부모와 자식 사이에서 만들어진다. 

paymentService.prepare() 를 사용하는 client와는 여전히 결합도를 낮게 유지할 수 있지만 상속관계의 결합도는 높게 유지된다. 

결합도는 여러 관계 속에서 높을 수도 낮을 수도 있다. 왜냐하면 객체가 지닌 관계는 여러개이기 때문이다. 
(단순 참조, 상속, 구현 등등)

우리가 Provider 라는 객체를 분리해야한다는 판단은 무엇으로 부터 얻는가?
환율을 가져오는 책임은 우리의 예상에서 변경의 여지가 높다. 환율은 변동율이 매우 높은 수치이며 이 수치가 매우 빠르게 변한다는 특징 덕분에 우리는 특정 시점의 값을 보고 싶다, 지금의 값을 보고 싶다 등 여러 요구사항이 갈라질 수 있음을 예상할 수 있다. 

책임을 분리하면서 우리는 자연스레 높은 응집도를 가진 객체를 만들 수 있다. 
PaymentService는 결제를 준비한다는 책임을, ExRateProvider는 환율을 가져온다는 책임만을 수행한다. 
자기가 가진 책임과 관련된 코드만 지닐 수록 높은 응집도를 가진 객체라고 평가할 수 있다. 

나아가 더 낮은 결합도, 더 높은 응집도를 추구할 수는 없을까? 
client 코드에서 조차 WebApiExRateProvider 인지, SimpleExRateProvider 인지도 모를 수는 없을까? 
관심사를 더 좁혀보자. 어떤 객체를 선택할까? 라는 지극히 프로그래밍적 사고조차도 역할 혹은 책임이 될 수 있다. 

ObjectFactory 라는 객체가 탄생함으로써, Client는 비로소 PaymentService가 어떻게 환율을 가져오는지 조차도 모르게 되었다. 객체간 어떤 관계가 있는지 알고 결정하는 책임은 ObjectFactory가 가져갔다. 
PaymentService가 어떤 환율 생성기를 사용할지 제어하는 역할이 점점 옮겨가는 것을 느껴보자. 

스프링은 최종적으로 이 제어의 역전이라는 개념을 핵심으로 사용한다. 
우리는 에시를 통해 컴퓨터 시스템이라는 큰 세상의 아주 극히 일부인 객체간의 제어의 역전을 보았다.
하지만 컴퓨터 시스템에서는 개발자와 객체와의 관계도 있다. 이 제어를 프레임워크에 역전하는 것이 스프링의 제어의 역전 개념이다.  

#### 객체지향은 현실세계의 재구성

우리는 앞서 객체가 발전되어가는 과정을 통해 객체가 굉장히 유동적인 개념임을 느낄 수 있었다. 

혹자는 객체지향이 현실세계를 코드로 표현하는 방법이라고들 한다. 현실세계가 여러 객체들의 상호작용으로 이루어지는 것처럼 코드도 적절한 객체로 쪼개면 객체간 상호작용을 통해 큰 시스템을 잘 관리할 수 있게된다는 의미에서는 적절하다. 
하지만 객체가 어떻게 발전하는지는 표현하지 못한다. 그래서 나는 재구성이라는 단어를 쓰고 싶다. 

현실세계에서는 손가락이 접히는 현상을 이야기할 때, 내가 손가락을 접는다는 문장으로 쉽게 표현가능하다. 
주어가 있고 목적어가 있으며 동사가 있다. 주어는 동사를 통해 목적어를 제어한다. 

```
public class Person {
    private List<Finger> fingers;

    public void holdFinger(int order) {
        Finger finger = fingers.get(order);
        finger.state = FingerState.BENT; // ❌ 외부에서 Finger의 상태를 바꿈
    }
}
```
코드에서는 Person -> Finger 정도로 표현할 수 있겠다. 

```
public class Person {
    private List<Finger> fingers;

    public void holdFinger(int order) {
        Finger finger = fingers.get(order);
        finger.hold(); // ✅ 손가락이 스스로 접힌다
    }
}

public class Finger {
    private FingerState state = FingerState.STRAIGHT;

    public void hold() {
        this.state = FingerState.BENT; // ✅ Finger 스스로 자신의 상태를 바꾼다
        System.out.println("손가락이 접혔습니다.");
    }
}

enum FingerState {
    STRAIGHT, BENT
}

```
그러나 객체지향 세상에서는 행동의 주체가 내가 아니다. 
손가락을 움직이는 주체는 손가락이 되어야한다. 
현실세계에서는 좀 어색한 개념이지만 프로그래밍에서는 가능하다.

위 처럼 작성된 코드가 더 좋은 코드이다. 
사람은 손가락이 '어떻게 접는지' 몰라도 되며 손가락이 그 책임을 온전히 다한다. 
사람은 사람의 일을, 손가락은 손가락의 일에 최선을 다할 수 있는 상태가 된다.
